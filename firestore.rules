
/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where all data is private by default.
 * Users can only access data that exists within their own user document tree. This ensures a high level of
 * security and data isolation between users.
 *
 * Data Structure: The data is organized hierarchically. A top-level 'users' collection stores user profile
 * documents. All other user-specific data, such as 'issues', is stored in subcollections under that
 * user's specific document (e.g., /users/{userId}/issues/{issueId}).
 *
 * Key Security Decisions:
 * - Comprehensive Data Validation: Create and Update operations are validated against strict functions
 *   (e.g., `validateIssueDataOnCreate`) to ensure data integrity, correct types, and proper initial state.
 *   This prevents malformed or malicious data from entering the database, a key OWASP principle.
 * - Path-Based Security & Role Checks: Ownership is determined by the document's path (`isOwner`).
 *   Privileged access for 'Admin', 'it-support', and 'Root' roles is granted via helper functions that
 *   check the user's role from their own user document, providing a secure and centralized logic.
 *
 * User Roles & Permissions:
 * - Root: Super user (hardcoded email). Has unrestricted access.
 * - Admin: Can manage users and tickets across assigned regions. Has efficient access to collection group queries.
 * - it-support: Can manage tickets across assigned regions. Lacks permission for efficient collection group queries.
 * - Branch / User: Standard user who can only manage their own tickets.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ========== HELPER FUNCTIONS ==========
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isRoot() {
      return isSignedIn() && request.auth.token.email == 'mustansir133@gmail.com';
    }
    
    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }
    
    function isUserRole(userId, role) {
      return getUserData(userId).role == role;
    }

    function isAdmin() {
      return isUserRole(request.auth.uid, 'Admin');
    }
    
    function isSupport() {
      return isUserRole(request.auth.uid, 'it-support');
    }

    function canManageTickets() {
      // Always allow root user first.
      if (isRoot()) {
        return true;
      }
      // For other users, check for their document and role.
      let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
      if (!exists(userDocPath)) {
        return false; // Not root and no user profile, so no special roles.
      }
      let userRole = get(userDocPath).data.role;
      return userRole == 'Admin' || userRole == 'it-support';
    }

    // ========== DATA VALIDATION FUNCTIONS ==========

    function validateUserDataOnCreate(data) {
        return data.keys().hasAll(['displayName', 'email', 'role', 'phoneNumber']) &&
               data.keys().hasAny(['region', 'regions']) &&
               data.displayName is string && data.displayName.size() > 0 &&
               data.email is string &&
               data.role in ['User', 'Branch', 'it-support', 'Admin'];
    }
    
    function validateUserDataOnUpdate(data, existingData) {
        // A user can only update their own displayName and phoneNumber
        let selfUpdateAllowed = request.auth.uid == existingData.id &&
                                data.diff(existingData).affectedKeys().hasOnly(['displayName', 'phoneNumber']);

        // Root can update role and regions
        let rootUpdateAllowed = isRoot() &&
                                data.diff(existingData).affectedKeys().hasAny(['displayName', 'role', 'region', 'regions']);
                                
        return selfUpdateAllowed || rootUpdateAllowed;
    }
    
    function validateIssueDataOnCreate(data) {
        let requiredKeys = ["userId", "title", "issueType", "description", "status", "createdAt", "updatedAt", "region", "unreadByAdmin", "unreadByUser"];
        let optionalKeys = ["customIssueType", "anydesk"];
        
        return data.keys().hasAll(requiredKeys) &&
               data.keys().hasOnly(requiredKeys.concat(optionalKeys)) &&
               data.userId == request.auth.uid &&
               data.title is string && data.title.size() > 0 &&
               data.description is string && data.description.size() > 0 &&
               data.status == 'Pending' && // Issues must always be created as 'Pending'
               data.issueType is string &&
               data.region is string &&
               data.createdAt == request.time && // Must be server timestamp
               data.updatedAt == request.time &&
               data.unreadByAdmin == true &&
               data.unreadByUser == false;
    }

    function validateIssueDataOnUpdate(data, existingData) {
        // Keys a ticket owner is allowed to change (e.g., when they send a new message)
        let ownerAffectedKeys = ['updatedAt', 'unreadByAdmin'];
        
        // Keys a support agent/admin can change
        let managerAffectedKeys = ['status', 'updatedAt', 'completedAt', 'resolvedBy', 'resolvedByDisplayName', 'unreadByAdmin', 'unreadByUser'];

        return (isOwner(existingData.userId) && data.diff(existingData).affectedKeys().hasOnly(ownerAffectedKeys)) || 
               (canManageTickets() && data.diff(existingData).affectedKeys().hasAny(managerAffectedKeys));
    }
    
    function validateChatMessageData(data) {
        let requiredKeys = ["userId", "displayName", "createdAt", "isRead", "type"];
        let optionalKeys = ["text", "audioUrl", "link"];

        return data.keys().hasAll(requiredKeys) &&
               data.keys().hasOnly(requiredKeys.concat(optionalKeys)) &&
               data.userId == request.auth.uid &&
               data.displayName is string &&
               (data.type == 'user' || data.type == 'call_request') &&
               data.createdAt == request.time &&
               data.isRead == false;
    }


    // ========== COLLECTION GROUP RULES ==========
    match /{path=**}/issues/{issueId} {
      allow get: if canManageTickets();
      // 'list' is restricted for performance. Firestore doesn't allow `get` in `list` rules for non-admin/root users.
      // The app handles this by fetching tickets iteratively for 'it-support' roles.
      allow list: if isRoot() || isAdmin(); 
    }

    match /{path=**}/notifications/{notificationId} {
      // Allow admins to query all notifications to check read status for announcements.
      allow list, get: if isRoot() || isAdmin();
    }


    // ========== PATH-BASED RULES ==========
    match /users/{userId} {
      allow get: if isOwner(userId) || canManageTickets();
      allow list: if canManageTickets();
      allow create: if (isOwner(userId) || isRoot()) && validateUserDataOnCreate(request.resource.data);
      allow update: if validateUserDataOnUpdate(request.resource.data, resource.data);
      allow delete: if isOwner(userId) || isRoot(); // Deletion should be rare, restricted to owner or root.
      
        match /notifications/{notificationId} {
            allow get, list: if isOwner(userId) || canManageTickets();
            allow create: if canManageTickets(); // Only privileged users can send notifications
            allow update: if isOwner(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);
            allow delete: if canManageTickets();
        }

        match /issues/{issueId} {
          allow get, list: if isOwner(userId) || canManageTickets();
          allow create: if isOwner(userId) && validateIssueDataOnCreate(request.resource.data);
          allow update: if validateIssueDataOnUpdate(request.resource.data, resource.data);
          allow delete: if isOwner(userId) || canManageTickets();

            match /messages/{messageId} {
                allow list, get: if isOwner(userId) || canManageTickets();
                allow create: if (isOwner(userId) || canManageTickets()) && validateChatMessageData(request.resource.data);
                allow update: if (isOwner(userId) || canManageTickets())
                            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);
            }
        }
    }
    
    match /announcements/{announcementId} {
      allow get, list, create: if canManageTickets();
      // Updates are not expected from the client.
      allow update, delete: if isRoot(); 
    }

    match /system_settings/{settingId} {
      allow get, list: if canManageTickets(); 
      allow write: if isRoot(); // Only root can change global settings like regions
    }
  }
}
